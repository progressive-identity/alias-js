<html>
    <head>
        <title>ðŸ”’ Authorize request</title>

        <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
        <script type="application/javascript" src="/jquery-3.4.1.min.js"></script>
        <script type="application/javascript" src="/header.js"></script>
        <script type="application/javascript" src="/sodium.js"></script>
        <script type="application/javascript" src="/anychain.js"></script>
        <script type="application/javascript" src="/alias.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

        <style>
        html {
            font-family: 'Roboto', sans-serif;
            background-color: #f0f0f0;
        }

        .title {
            font-size: 120%;
            font-weight: bold;
        }

        #popup {
            display: none;
            background-color: white;
            width: 550px;
            border: 1px solid #ccd6dd;
            border-radius: 4px;
            padding: 20px;
            margin-top: 40px;
            margin-left: auto;
            margin-right: auto;
        }

        #popup-content {
            position: relative;
            /*margin-right: 250px;*/
        }

        #client {
            position: absolute;
            top: 0;
            right: -250px;
            width: 230px;
            color: #8899a6;
        }

        .desc {
            font-size: 80%;
        }

        #advanced {
            color: gray;
            font-size: 80%;
        }

        #advanced-info {
            color: gray;
            font-size: 90%;
            overflow-wrap: break-word;
        }
        </style>
    </head>

    <html>
        <div id="popup">
        <div id="popup-content">
            <p class="title">ðŸ”’ <em>{{ client.body.name }}</em> is requesting
            access to your data</p>

            <blockquote class="usage" v-if="client.body.legal && client.body.legal.usage">
                {{ client.body.legal.usage }}
            </blockquote>

            <p>This application will access to the following data:</p>
            <ul>
                <li v-for="scope in scopes">
                    <code>{{ scope }}</code>
                </li>
            </ul>

            <div v-if="consentScopes.length > 0">
                <p>To fulfill the request,</p>
                <ul>
                <li v-for="(scope, i) in consentScopes">
                    Do you also consent to share data scoped <code>{{ scope }}</code>?
                    <input type="radio" v-model="consent[i]" :value="true">Yes
                    <input type="radio" v-model="consent[i]" :value="false">No
                </li>
                </ul>
            </div>

            <p>Your data will be shared with <em>{{client.body.name}}</em>
                <span v-if="client.body.legal && client.body.legal.third">
                    and <em v-for="t in client.body.legal.third">{{t}}</em>
                </span>
            .</p>

            <button v-on:click="agree">I agree</button>
            <button v-on:click="deny">I deny</button>

            <p><a href="#" id="advanced" v-on:click="toggleAdvanced">Advanced</a></p>
            <div id="advanced-info" v-show="showAdvanced">
                <p>
                    Your key: <code>{{userPublicKey}}</code><br />
                    Requester's key: <code>{{clientSignerH}}</code><br />
                    Client token hash: <code>{{clientH}}</code><br />
                    Request date: <code>{{client.date}}</code>
                </p>
            </div>
        </div>
        </div>

    <script>

var vue = null;

function bytesEq(a, b) {
    // XXX TODO
    return sodium.to_base64(a) == sodium.to_base64(b);
}

function cbReturnError(client, error, desc, uri) {
    const state = (new URL(window.location.href)).searchParams.get('state');

    url = client.body.redirect_url + "?";
    url = url + "error=" + encodeURIComponent(error);
    if (desc)  url = url + "&error_description=" + encodeURIComponent(desc);
    if (uri)   url = url + "&error_uri=" + encodeURIComponent(uri);
    if (state) url = url + "&state=" + encodeURIComponent(state);

    window.location.href = url;
}

function cbReturn(client, grant) {
    const state = (new URL(window.location.href)).searchParams.get('state');

    let url = client.body.redirect_url + "?";
    url = url + "code=" + encodeURIComponent(chain.toToken(grant));
    if (state) url = url + "&state=" + encodeURIComponent(state);

    window.location.href = url;
}

function cbProcessReturn(client, grant) {
    const state = (new URL(window.location.href)).searchParams.get('state');

    let url = grant.body.fetch.frontURL + "?";
    url = url + "code=" + encodeURIComponent(chain.toToken(grant));
    if (state) url = url + "&state=" + encodeURIComponent(state);

    window.location.href = url;
}

function run() {
    if (!currentUserSeed()) {
        const url = new URL(window.location.href);
        const pathname = url.pathname + url.search;
        window.location.href = "/login/?redirect=" + encodeURIComponent(pathname);
    }

    const selfPublicKey = openBox().sign.publicKey;
    if (!selfPublicKey) { throw "no sign publicKey set"; }

    const url = new URL(window.location.href);
    const clientId = url.searchParams.get('client_id');

    const allScopes = url.searchParams.get('scopes').split(' ');
    const scopes = allScopes.filter((s) => !s.startsWith('?'));
    const consentScopes = allScopes.filter((s) => s.startsWith('?')).map((s) => s.substr(1));
    let consent = [];
    consent.length = consentScopes.length;
    consent.fill(false);

    $.ajax(clientId)
        .catch(() => {
            alert("invalid client");
        })
        .then((r) => {
            let client = null;
            try {
                client = chain.fromJSON(r);
                chain.verify(client);
                if (client.body.type != 'alias.client.decl') {
                    throw "bad client declaration";
                }

                chain.validate(client, (o) => {
                    if (o.body.type == 'alias.client.decl') {
                        if (!bytesEq(o.body.crypto.sign, o.signer)) {
                            throw "bad client declaration: bad signer";
                        }
                    }
                });
            } catch(e) {
                console.error(e);
                cbReturnError(client, "unauthorized_client");
            }

            return client;
        })
        .then((client) => {
            vue = new Vue({
                el: "#popup",
                data: {
                    client: client,
                    clientH: chain.fold(client).base64(),
                    scopes: scopes,
                    consentScopes: consentScopes,
                    consent: consent,
                    userPublicKey: sodium.to_base64(selfPublicKey),
                    clientSignerH: sodium.to_base64(client.signer),
                    showAdvanced: false,
                },
                methods: {
                    toggleAdvanced: function() {
                        this.showAdvanced = !this.showAdvanced;
                    },
                    agree: function() {
                        let scopes = [...this.scopes];
                        for (let i in this.consentScopes) {
                            if (this.consent[i]) {
                                scopes.push("?" + this.consentScopes[i]);
                            }
                        }

                        const url = new URL(window.location.href);
                        const frontURL = url.origin + "/process/";

                        let grant = {
                            type: "grant",
                            scopes: scopes,
                            client: client,
                            fetch: {
                                frontURL: frontURL,
                            }
                        };
                        grant = chain.sign(openBox().sign, grant);

                        console.log(chain.toToken(grant));

                        cbProcessReturn(client, grant);
                    },
                    deny: function() {
                        cbReturnError(client, "access_denied");
                    },
                }
            });
            $("#popup").show();
        })
        .catch(() => {
            alert("something went wrong");
            // XXX cb error
        })
    ;
};

    </script>
    </html>
</html>

